boolean --- Примітивний тип даних у TypeScript, що може набувати лише двох значень: `true` (істина) або `false` (хиба). Він використовується для логічних операцій, умовних виразів і контролю потоку програми.



number --- Примітивний тип даних у TypeScript, який використовується для представлення як цілих, так і дробових чисел. Він охоплює всі числові значення в JavaScript, включаючи *NaN*, *Infinity* і *-Infinity*.



string --- Примітивний тип даних у TypeScript, який використовується для представлення текстових значень. Він охоплює будь-яку послідовність символів, що записується в одинарних, подвійних або зворотних лапках.



null --- Спеціальний тип у TypeScript, що вказує на відсутність або неіснування значення. Використовується для позначення того, що змінна не має значення або не вказує на об'єкт, і є одним з можливих значень для змінних типу, що може бути присвоєно лише явно.



undefined --- Тип даних у TypeScript, який вказує на те, що змінна була оголошена, але не ініціалізована значенням. Це значення автоматично присвоюється змінній, яка не має явно визначеного значення, або не була ініціалізована під час оголошення.



object --- Тип даних у TypeScript, який використовується для позначення значень, що є об'єктами. Це може включати колекції даних у вигляді пар "ключ-значення" або складніші структури, такі як масиви чи функції.



any --- Тип даних у TypeScript, який дозволяє змінній приймати значення будь-якого типу без перевірки типу під час компіляції. Використання цього типу вимикає систему типів для відповідної змінної, що може призвести до помилок у коді, якщо не бути обережним. Його зазвичай застосовують у ситуаціях, коли точний тип заздалегідь невідомий або коли потрібно поступово впроваджувати типізацію.



unknown --- Тип даних у TypeScript, який використовується для позначення значень, чий тип невідомий на момент компіляції. Значення цього типу можуть бути будь-яким, але перед використанням потрібно виконати перевірку типу або привести його до конкретного типу. Цей тип є більш безпечним, ніж *any*, оскільки вимагає явної перевірки типу перед використанням.



never --- Тип, що використовується для позначення значень, які *ніколи не виникають*. Це означає, що функція або вираз, які мають цей тип, *ніколи не завершуються успішно* або *ніколи не повертають значення*. Наприклад, функція, яка завжди викидає помилку або має нескінченний цикл.



void --- Тип, що використовується для позначення того, що функція *не повертає жодного значення*. Це зазвичай застосовується до функцій, які виконують дію (наприклад, вивід у консоль), але *не мають результату*, що повертається.



number[] --- Тип, що описує *масив*, елементи якого є *числовими значеннями*. Це означає, що всі значення в масиві мають бути числового типу.



Array<number> --- Tип, що описує *масив*, який містить лише *числові елементи*. Це альтернативний запис, який використовує узагальнений (*generic*) синтаксис для визначення типу елементів масиву.



type User = {
  name: string;
  age: number;
  action: () => void;
}; --- Користувацький тип *User*, який описує структуру об'єкта з такими властивостями:

- *name*: рядок
- *age*: число
- *action*: функція без параметрів, яка нічого не повертає



interface User {
  name: string;
  age: number;
  action: () => void;
} --- Інтерфейс з ім’ям *User*, який описує структуру об’єкта з двома властивостями:

- *name*: рядок
- *age*: число
- *action*: функція без параметрів, яка нічого не повертає



(number | string)[] --- Tип масиву, елементами якого можуть бути як *числа*, так і *рядки*.



string | number | boolean --- *Об’єднаний тип* (union type), який дозволяє змінній або параметру приймати *одне зі значень трьох типів*: *string*, *number* або *boolean*.



enum Role {
 ADMIN,
 USER,
} --- *Перелічуваний тип* (*enumeration*), який дозволяє визначити набір **іменованих констант**.

Цей *enum* створює перелік ролей з двома значеннями:

- *Role.ADMIN* дорівнює *0*
- *Role.USER* дорівнює *1*

Такі конструкції зручно використовувати для представлення *фіксованих множин значень*, наприклад, типів користувачів, статусів, режимів тощо.



enum Role {
 ADMIN = 'admin',
 USER = 'user',
} --- *Строковий перелічуваний тип* (*string enum*), який визначає набір *іменованих констант*, де кожному елементу відповідає конкретне *рядкове значення*.

У цьому випадку:

- *Role.ADMIN* дорівнює *'admin'*
- *Role.USER* дорівнює *'user'*



const enum HttpCodes {
  OK = 200,
  BadRequest = 400,
  Unauthorized = 401,
} --- Це константний перелік (*const enum*), що визначає набір іменованих числових значень для HTTP-кодів відповіді сервера.

- *HttpCodes* — ім’я переліку (типу), який групує пов’язані між собою значення.
- *OK* — ключ, що позначає успішну відповідь; має значення *200*.
- *BadRequest* — ключ, що означає помилку клієнта; має значення *400*.
- *Unauthorized* — ключ, що вказує на відсутність авторизації; має значення *401*.

Значення ключів є стандартними HTTP-статусами. Коли використовується *const enum*, компілятор TypeScript замінює посилання на ключі напряму на числа (*HttpCodes.OK → 200*) у скомпільованому коді.



type CEO = Employee & Manager; --- Це визначення нового типу *CEO*, що є *перетином (intersection)* двох інших типів — *Employee* та *Manager*. Конструкція вказує, що об'єкт типу *CEO* повинен одночасно мати всі властивості, визначені як у *Employee*, так і у *Manager*.



type YesOrNo = 'yes' | 'no'; --- Це *літеральний тип* у TypeScript. Він обмежує значення змінної лише двома конкретними рядками — *'yes'* або *'no'*.

- *YesOrNo* — ім’я типу.
- *'yes' і 'no'* — об’єднання літералів (union type), яке дозволяє значенням цього типу бути лише *'yes'* або *'no'*.

Цей тип корисний, коли необхідно явно задати обмежений набір допустимих значень замість загального типу *string*.



type TypeName = (...nums: number[]) => number; --- Це кастомний тип *TypeName*, який описує функцію, що приймає *будь-яку кількість числових аргументів* *...nums* і повертає число.



type TypeName = [number, number]; --- Оголошення *кортежу TypeName* — типу масиву з *фіксованою кількістю елементів визначених типів*. 2 елементи числового типу.



function fn(arg?: number) {
  // code
} --- Оголошення функції з іменем *fn*, яка має один *необов’язковий параметр* *arg* типу *number*. Функція має блок коду *// code*



type User = {
  name: string;
  age?: number;
}; --- Оголошення *типу об’єкта* з назвою *User*, який описує структуру даних з двома властивостями:

- *name* — обов’язкова властивість типу *string*;
- *age* — необов’язкова властивість типу *number*.



interface TypeName extends Type1 {
 key: string;
} --- Це інтерфейс *TypeName*, який успадковує властивості з *Type1* і додає власну властивість:

- *key* — обов’язкова властивість типу *string*.



type TypeName = Type1 | Type2; --- Тип *TypeName*, який може бути або типом *Type1*, або типом *Type2*. Іншими словами, змінна з типом *TypeName* повинна відповідати *одному з цих двох типів*, але *не обом одночасно*.



class ClassName implements Class1, Class2 {
  // code
} --- Оголошення класу *ClassName*, який *зобов’язується реалізувати всі властивості та методи*, визначені в інтерфейсах *Class1* та *Class2*. Інакше кажучи, клас *впроваджує контракти* з обох інтерфейсів. І має тіло *// code*



## Type Guards

typeof --- (Type Guards)

Спеціальна конструкція, яка дозволяє *перевіряти тип значення під час виконання* (runtime), щоб компілятор міг *звузити тип* і застосувати до нього відповідні перевірки й методи.

Це умовне вираження, яке дозволяє TypeScript з’ясувати тип змінної *під час виконання* і автоматично *звузити тип змінної* в рамках блоку *if*.

Це особливо корисно у функціях або умовах, де ви працюєте з *різними типами даних*, і потрібно поводитись із ними по-різному.



in --- (Type Guards)

Оператор, що використовується як *Type Guard*, щоб визначити, чи існує певна властивість у об’єкті. Це дозволяє компілятору *звузити тип* об’єкта до більш конкретного підтипу на основі наявності ключа (властивості).

Логічна перевірка, яка визначає, чи містить об’єкт певну властивість, що дозволяє компілятору TypeScript *звузити тип змінної* в умовному блоці коду. Повертає *true*, якщо вказане ім’я властивості присутнє в об’єкті або його прототипі.

*Для чого використовується*

- Для *розрізнення типів* у *дискримінованих об’єднаннях* (union types).
- Для *безпечного доступу* до властивостей, які можуть існувати лише у певних типах.
- Для *звуження* складних або комбінованих типів до типу, який має конкретну властивість.



instanceof --- (Type Guards)

Перевірка типу, яка визначає, чи створений об’єкт є *екземпляром певного класу або успадкованого класу*. Це дозволяє TypeScript *точніше виводити типи* при виконанні умов.

*Для чого використовується*

- Для *перевірки належності* об'єкта до класу.
- Для *звуження типів* у випадках, коли об'єкт може бути екземпляром різних класів.
- Для *безпечного доступу* до властивостей і методів, характерних лише певному класу.

Оператор є корисним при роботі з *об’єктно-орієнтованими структурами* і підтримує *типобезпечний контроль логіки* у складних типах.



<string>someValue --- (Type Guards)

Приведення типу (*Type Assertion*) значення *someValue* до типу *string*. Це явне вказування компілятору, що значення *someValue* слід розглядати як тип *string*, навіть якщо воно має ширший або невизначений тип.



someValue as string --- (Type Guards)

*Явне приведення типу* (*Type Assertion*). Означає, що змінну або вираз *someValue* слід інтерпретувати як тип *string*. Це *не змінює значення* в рантаймі, а лише інформує компілятор про очікуваний тип.

Рекомендований синтаксис у середовищах, де використовуються *JSX/TSX*.



elem as HTMLInputElement --- (Type Guards)

Інструкція компілятору TypeScript, що змінна *elem* повинна розглядатися як *елемент HTML типу <input>*.

Рекомендований синтаксис у середовищах, де використовуються *JSX/TSX*.



type IndexType = {
  [prop: string]: string;
} --- (Type Guards)

Оголошення типу об'єкта *IndexType*, у якому:

- *ключі* (*prop*) мають тип *string* (тобто можуть бути будь-яким рядком),
- *значення* — також рядки (*string*).

Такий тип описує об'єкти, де ключі не наперед визначені, але всі значення мають один і той самий тип — *string*.