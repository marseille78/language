# Generics

Array<string | number> --- Узагальнений тип (generic type), який представляє масив, що може містити елементи типу string або number.



const promise: Promise<string> = new Promise((resolve) => {
  // code
}); --- *Узагальнений тип* об'єкта *Promise*, який означає, що цей проміс поверне значення в змінну *const promise* типу *string*, коли буде виконано.

В промісі виконується блок коду

(resolve) => {
  // code
}



function foo<T>(arg: T): T {
  // code
} --- Це універсальна функція *foo* з узагальненим типом *T*, яка приймає аргумент *arg* типу *T* і повертає значення того самого типу *T* і виконує блок коду *code*.



const val = foo<string>("str"); --- Це *виклик універсальної (generic) функції foo*, де явно вказано тип *string* як аргумент для узагальненого параметра *T*. Функція приймає аргумент *"str"* і зберігає результат в змінну *const val*.



function foo<T, U>(objA: T, objB: U) {
  // code
} --- Це узагальнена функція *foo*, яка приймає два параметри *objA*, *objB* різних типів, *T* і *U* відповідно, що визначаються під час виклику функції. Вона виконує блок коду *// code*.



function foo<T extends object, U extends object>(objA: T, objB: U) {
  // code
} --- Це функція *foo* з двома узагальненими параметрами типу — *T* і *U*, — які *повинні бути об'єктами*. Обмеження гарантує, що аргументи функції *objA* і *objB* будуть саме об’єктами (а не, наприклад, рядками чи числами). Функція виконує блок коду *// code*.



T extends object, U extends object --- *Оголошенням обмежень (constraints)* для узагальнених типів *T* і *U*. Типи *T* і *U* повинні бути об’єктами. TypeScript не дозволить передавати в такі параметри прості типи, як *string*, *number*, *boolean* тощо.



function foo<T extends Type1>(str: T) {
  // code
} --- Це оголошення узагальненої функції *foo* з *обмеженням типу*, де параметр типу *T* повинен бути підтипом або самим типом *Type1*. Параметр функції *str* має тип *T*, функція виконує блок коду *// code*.



type TypeName = keyof Type1; --- Це оператор, який створює *уніон типів рядків*, що представляють усі *ключі* об’єкта *Type1* і зберігає в новий тип *TypeName*.



function foo<T extends object, U extends keyof T>(obj: T, key: U) {
  // code
} --- Ця конструкція описує генеричну функцію *foo* з обмеженнями для типів *T* та *U*.

- *T* — тип, що має бути об’єктом (тобто мати ключі).
- *U* — тип, що має бути одним із ключів об'єкта *T*.
- *obj* — параметр *obj* має тип *T*, тобто є об’єктом.
- *key* — параметр *key* — це ключ, який точно існує в об’єкті *T*.
- *// code* — тіло функції



T extends object, U extends keyof T --- *Обмеження для дженериків (Generics)* в TypeScript, які використовуються у функціях, типах або інтерфейсах, щоб гарантувати правильні зв’язки між типами.

- Тип *T* має бути об’єктом. Це гарантує, що *T* має ключі та значення.
- Тип *U* має бути *одним із ключів* об’єкта *T*. Це забезпечує безпечний доступ до властивостей об’єкта, визначеного типом *T*.



Partial<Type1> --- *Вбудований дженерик-утиліта* (utility type) в TypeScript, який створює новий тип на основі *Type1*, роблячи всі його властивості *необов’язковими*.



Readonly<Type1> --- Вбудований дженерик-утиліта (utility type) в TypeScript, який створює новий тип, де всі властивості типу *Type1* стають лише для читання (тобто, їх не можна змінювати після ініціалізації).



const arr: Readonly<number[]> = [1, 2, 3]; --- Оголошення константи *const arr*, яка є *масивом чисел*, але з обмеженням, що *елементи цього масиву не можна змінювати*, додавати чи видаляти. Масиву даємо значення *[1, 2, 3]*.

- *arr* з таким типом *не допускає* операцій на зміну масиву, таких як *push*, *pop*, *splice* тощо.

Тобто, це масив чисел, який дозволено лише читати, але не змінювати.



type TypeName = Pick<Type1, 'key1' | 'key2'>; --- Створення нового типу *TypeName*, який містить тільки обрані властивості (*'key1'* і *'key2'*) з існуючого типу *Type1*.



type TypeName = Omit<Type1, 'key1' | 'key2'>; --- Створення нового типу *TypeName*, який містить усі властивості типу *Type1*, крім *'key1'* та *'key2'*.



type TypeName = Record<Type1, string>; --- Створення нового типу *TypeName*, у якому усі ключі, задані типом *Type1*, мають значення типу *string*.



type TypeName = ReturnType<typeof foo>; --- Узагальнена конструкція TypeScript, яка визначає тип *TypeName*, що відповідає типу значення, яке повертає функція *foo*.



type ParamsType = Parameters<FnType>; --- Це узагальнена (generic) конструкція TypeScript, яка визначає кортеж типів аргументів функції *FnType*. І зберігає його до типу *ParamsType*



type NonType = NonNullable<Type1>; --- Це узагальнена (generic) конструкція в TypeScript, яка створює новий тип *NonType*, виключаючи з *Type1* значення *null* та *undefined*.